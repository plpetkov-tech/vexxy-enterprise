# VEXxy Premium Analysis Service

**Automated reachability-based VEX generation through runtime analysis with Kubescape**

This service provides the Ultimate tier feature for VEXxy - proving vulnerability reachability through runtime evidence, not just static analysis.

## üöÄ Now Powered by Kubescape!

The service now integrates with **Kubescape** for production-grade runtime analysis and VEX generation. See [KUBESCAPE_ARCHITECTURE.md](./KUBESCAPE_ARCHITECTURE.md) for details.

---

## Features

- üîí **Isolated Kubernetes Execution** - Deploy workloads in monitored sandbox environments
- üìä **Runtime Analysis** - Kubescape automatic runtime monitoring with eBPF
- üéØ **Reachability Analysis** - Kubescape determines which CVEs are actually reachable
- üìÑ **Automated VEX Generation** - OpenVEX documents generated by Kubescape
- üîç **Filtered SBOMs** - Only components actually used at runtime
- ‚ö° **Async Processing** - Celery workers for scalable analysis
- üìà **Progress Tracking** - Real-time job status and progress updates
- ‚úÖ **High Confidence** - Production-grade analysis from official Kubescape tooling

---

## Architecture

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  FastAPI API    ‚îÇ ‚Üê REST API for job submission
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
         ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Celery Worker   ‚îÇ ‚Üê Async processing
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
         ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Kubernetes Sandbox Manager         ‚îÇ
‚îÇ  ‚Ä¢ Creates isolated Jobs            ‚îÇ
‚îÇ  ‚Ä¢ Manages profiling sidecars       ‚îÇ
‚îÇ  ‚Ä¢ Collects execution evidence      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
         ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Reachability Analyzer              ‚îÇ
‚îÇ  ‚Ä¢ Maps CVEs to code                ‚îÇ
‚îÇ  ‚Ä¢ Determines execution status      ‚îÇ
‚îÇ  ‚Ä¢ Calculates confidence scores     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
         ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  VEX Document Generator             ‚îÇ
‚îÇ  ‚Ä¢ OpenVEX format                   ‚îÇ
‚îÇ  ‚Ä¢ Evidence attachment              ‚îÇ
‚îÇ  ‚Ä¢ Cryptographic signing            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## Quick Start

> **üöÄ New:** Use `./dev.sh` for one-command setup!

### Prerequisites

- Docker & Docker Compose
- kubectl (with access to Kubernetes cluster)
- Kubernetes cluster with:
  - Kubescape installed in `kubescape` namespace
  - OWASP ZAP installed in `security` namespace

### One-Command Start

```bash
cd premium-service

# Start everything and follow logs (Ctrl+C to stop)
./dev.sh run

# Or start in background
./dev.sh start
```

**That's it!** The script automatically handles:
- ‚úì Port-forwarding to OWASP ZAP
- ‚úì Building and starting all services
- ‚úì Running database migrations
- ‚úì Health checks and status monitoring

### Available Commands

```bash
./dev.sh start      # Start all services in background
./dev.sh stop       # Stop services (keeps data)
./dev.sh down       # Stop and remove volumes (clean slate)
./dev.sh restart    # Restart everything

./dev.sh status     # Show service health
./dev.sh logs       # Show all logs
./dev.sh test       # Run health checks

./dev.sh shell api  # Open shell in container
./dev.sh psql       # Connect to database
./dev.sh help       # Show all commands
```

### Service Endpoints

- **API**: http://localhost:8001
- **API Docs**: http://localhost:8001/docs
- **Flower**: http://localhost:5555 (Celery monitoring)
- **PostgreSQL**: localhost:5432
- **Redis**: localhost:6379

### Quick Test

```bash
# Submit analysis job with standard profile (recommended)
curl -X POST http://localhost:8001/api/v1/analysis/submit \
  -H "Content-Type: application/json" \
  -d '{
    "image_ref": "nginx:latest",
    "image_digest": "sha256:abc123...",
    "profile": "standard"
  }'

# Or use minimal profile for faster results
curl -X POST http://localhost:8001/api/v1/analysis/submit \
  -H "Content-Type: application/json" \
  -d '{
    "image_ref": "nginx:latest",
    "image_digest": "sha256:abc123...",
    "profile": "minimal",
    "config": {
      "ports": [80]
    }
  }'

# Check status
curl http://localhost:8001/api/v1/analysis/{job_id}/status

# Get results (when complete)
curl http://localhost:8001/api/v1/analysis/{job_id}/results
```

**üí° Tip:** See [Analysis Profiles Guide](./docs/ANALYSIS_PROFILES.md) for profile selection and configuration options.

---

## Development

### Local Setup (without Docker)

```bash
# Create virtual environment
python -m venv venv
source venv/bin/activate  # or `venv\Scripts\activate` on Windows

# Install dependencies
pip install -r requirements.txt
pip install -r requirements-dev.txt

# Set environment variables
export DATABASE_URL=postgresql://vexxy:vexxy@localhost:5432/vexxy_premium
export REDIS_URL=redis://localhost:6379/0

# Run API server
python api/main.py
# or with uvicorn
uvicorn api.main:app --reload --port 8001

# Run Celery worker (in another terminal)
celery -A workers.celery_app worker --loglevel=info

# Run Celery Flower (monitoring)
celery -A workers.celery_app flower --port=5555
```

### Running Tests

```bash
# Install test dependencies
pip install -r requirements-dev.txt

# Run all tests
pytest

# Run with coverage
pytest --cov=. --cov-report=html

# Run specific test file
pytest tests/test_api.py

# Run specific test
pytest tests/test_api.py::test_health_check -v
```

### Code Quality

```bash
# Format code with black
black .

# Sort imports
isort .

# Lint with ruff
ruff check .

# Type checking with mypy
mypy .
```

---

## API Reference

### Submit Analysis

**POST** `/api/v1/analysis/submit`

Submit container image for premium reachability analysis.

**Request:**
```json
{
  "image_ref": "nginx:latest",
  "image_digest": "sha256:abc123...",
  "sbom_id": "optional-uuid",
  "config": {
    "test_script": "optional custom script",
    "test_timeout": 300,
    "enable_fuzzing": true,
    "enable_profiling": true,
    "ports": [8080, 443],
    "environment": {
      "ENV_VAR": "value"
    }
  }
}
```

**Response:**
```json
{
  "job_id": "uuid",
  "status": "queued",
  "image_ref": "nginx:latest",
  "image_digest": "sha256:abc123...",
  "estimated_duration_minutes": 10,
  "created_at": "2025-11-13T10:00:00Z"
}
```

### Get Status

**GET** `/api/v1/analysis/{job_id}/status`

Get current status of analysis job.

**Response:**
```json
{
  "job_id": "uuid",
  "status": "running",
  "progress_percent": 50,
  "current_phase": "Executing tests",
  "started_at": "2025-11-13T10:00:00Z",
  "completed_at": null,
  "error_message": null
}
```

### Get Results

**GET** `/api/v1/analysis/{job_id}/results`

Get analysis results (only when status is "complete").

**Response:**
```json
{
  "job_id": "uuid",
  "status": "complete",
  "image_ref": "nginx:latest",
  "image_digest": "sha256:abc123...",
  "execution_profile": {
    "duration_seconds": 120,
    "files_accessed": ["/app/main.py"],
    "syscalls": ["read", "write"],
    "code_coverage_percent": 85.0
  },
  "reachability_results": [
    {
      "cve_id": "CVE-2024-12345",
      "status": "not_affected",
      "justification": "vulnerable_code_not_in_execute_path",
      "confidence_score": 0.87,
      "reason": "Vulnerable function exists but was not executed"
    }
  ],
  "generated_vex_id": "uuid"
}
```

### Cancel Analysis

**DELETE** `/api/v1/analysis/{job_id}`

Cancel running analysis job.

---

## Configuration

All configuration is done via environment variables (see `.env.example`).

**Key Settings:**

| Variable | Default | Description |
|----------|---------|-------------|
| `DATABASE_URL` | - | PostgreSQL connection string |
| `REDIS_URL` | - | Redis connection string |
| `K8S_SANDBOX_NAMESPACE` | `vexxy-sandbox` | Kubernetes namespace for sandbox jobs |
| `SANDBOX_CPU_LIMIT` | `2` | CPU limit for sandbox containers |
| `SANDBOX_MEMORY_LIMIT` | `4Gi` | Memory limit for sandbox containers |
| `DEFAULT_ANALYSIS_TIMEOUT` | `900` | Default analysis timeout (seconds) |

---

## Kubernetes Setup

The service requires a Kubernetes cluster for sandbox execution (e.g., kind, minikube, GKE, EKS).

### Option 1: Automatic Setup (Recommended)

The namespace will be **automatically created** on first use! Just ensure:

1. Your cluster is accessible via `kubectl`
2. Your kubeconfig is mounted in docker-compose (already configured)
3. Start the services: `docker-compose up`

The KubescapeService will automatically create the `vexxy-sandbox` namespace when it initializes.

### Option 2: Manual Setup

If you prefer to set up the cluster manually:

```bash
# Run the initialization script
./scripts/init-cluster.sh
```

This script will:
- ‚úÖ Create the `vexxy-sandbox` namespace
- ‚úÖ Label it appropriately
- ‚úÖ Check for Kubescape installation (auto-installed on first analysis if missing)

Or create the namespace manually:

```bash
kubectl create namespace vexxy-sandbox
kubectl label namespace vexxy-sandbox app=vexxy vexxy.dev/premium=true
```

### Testing with a Local Kubernetes Cluster

**Using kind:**
```bash
# Create a kind cluster
kind create cluster --name vexxy-test

# Verify connection
kubectl cluster-info

# Start vexxy services (namespace auto-created)
docker-compose up
```

**Using minikube:**
```bash
# Start minikube
minikube start

# Verify connection
kubectl cluster-info

# Start vexxy services (namespace auto-created)
docker-compose up
```

### Configure Access

**Local development (docker-compose):**
- Kubeconfig is auto-mounted from `~/.kube/config` (see docker-compose.yml line 81)
- Set `K8S_IN_CLUSTER=false` in `.env`

**Production (in-cluster):**
- Use Kubernetes service account
- Set `K8S_IN_CLUSTER=true`

### Set Up RBAC (TODO)

```bash
# Create service account and role binding
kubectl apply -f k8s/rbac.yaml
```

---

## Monitoring

### Celery Flower

Monitor Celery workers and tasks:

http://localhost:5555

- Task history
- Worker status
- Task execution times
- Failed tasks

### Prometheus Metrics (TODO)

Expose metrics on port 9090:

- Analysis jobs submitted
- Analysis jobs completed
- Analysis duration
- Sandbox job failures

---

## Troubleshooting

### Database Connection Errors

```bash
# Check PostgreSQL is running
docker-compose ps postgres

# Test connection
docker-compose exec postgres psql -U vexxy -d vexxy_premium -c "SELECT 1;"
```

### Celery Worker Not Processing Jobs

```bash
# Check worker logs
docker-compose logs -f worker

# Check Redis connection
docker-compose exec redis redis-cli ping

# Restart worker
docker-compose restart worker
```

### Kubernetes Job Failures

**Namespace not found error:**
```
"message":"namespaces \"vexxy-sandbox\" not found","reason":"NotFound","code":404}
```

This should not happen anymore (v0.2.0+) as the namespace is auto-created. If you see this error:
1. Check that your kubeconfig is valid: `kubectl cluster-info`
2. Restart the worker to trigger namespace creation: `docker-compose restart worker`
3. Or manually create it: `kubectl create namespace vexxy-sandbox`

**General job troubleshooting:**
```bash
# List sandbox jobs
kubectl get jobs -n vexxy-sandbox

# Check job logs
kubectl logs -n vexxy-sandbox job/vex-analysis-abc123

# Describe job
kubectl describe job -n vexxy-sandbox vex-analysis-abc123

# Clean up failed jobs
kubectl delete jobs -n vexxy-sandbox --field-selector status.successful=0

# Check if namespace exists
kubectl get namespace vexxy-sandbox

# View namespace events
kubectl get events -n vexxy-sandbox
```

---

## Development Roadmap

### ‚úÖ Phase 1: MVP (Weeks 1-2) - IN PROGRESS
- [x] FastAPI service skeleton
- [x] Database models
- [x] Celery workers
- [x] Basic K8s sandbox manager
- [ ] Job status tracking
- [ ] End-to-end test

### üîÑ Phase 2: Runtime Analysis (Weeks 3-4)
- [ ] Tracee integration (eBPF profiling)
- [ ] Execution profile collection
- [ ] Basic reachability algorithm
- [ ] Evidence collection

### üìã Phase 3: VEX Generation (Weeks 5-6)
- [ ] OpenVEX document generation
- [ ] Confidence scoring
- [ ] Callback to vexxy backend
- [ ] UI integration
- [ ] Quota enforcement

### üîí Phase 4: Production (Weeks 7-8)
- [ ] Security hardening
- [ ] gVisor isolation
- [ ] Monitoring and alerts
- [ ] Performance optimization

---

## Contributing

This is a private repository. For team members:

1. Create feature branch
2. Make changes
3. Run tests: `pytest`
4. Format code: `black . && isort .`
5. Submit PR

---

## License

**Proprietary** - VEXxy Enterprise Edition

---

## Documentation

- **[Analysis Profiles Guide](./docs/ANALYSIS_PROFILES.md)** - Profile selection and configuration
- **[OWASP ZAP Setup](./docs/OWASP_ZAP_SETUP.md)** - Security scanner configuration
- **[Kubescape Architecture](./KUBESCAPE_ARCHITECTURE.md)** - Runtime sandbox details
- **[API Docs](http://localhost:8001/docs)** - Interactive OpenAPI documentation

## Support

- **Issues**: Open GitHub issue
- **Questions**: Contact team

---

**Built with ‚ù§Ô∏è for the VEXxy Ultimate Tier**
