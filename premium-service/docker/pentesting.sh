#!/bin/bash
###############################################################################
# Vexxy Pentest Sidecar Script
#
# This script performs automated penetration testing on a target service
# to discover exploitable vulnerabilities during runtime VEX analysis.
#
# Arguments:
#   $1: Target service DNS name (e.g., "service.namespace.svc.cluster.local")
#   $2: Primary port to scan (e.g., "80")
#   $3: Maximum runtime in seconds (e.g., "300")
#
# Outputs:
#   - /pentest-output/summary.json: High-level summary of findings
#   - /pentest-output/report.json: Detailed scan results
#   - /pentest-output/pentest.log: Execution logs
###############################################################################

set -euo pipefail

# Input validation
TARGET_HOST="${1:-}"
TARGET_PORT="${2:-80}"
MAX_RUNTIME="${3:-300}"

if [ -z "$TARGET_HOST" ]; then
    echo "ERROR: Target host not specified" >&2
    exit 1
fi

# Output files
OUTPUT_DIR="/pentest-output"
SUMMARY_FILE="$OUTPUT_DIR/summary.json"
REPORT_FILE="$OUTPUT_DIR/report.json"
LOG_FILE="$OUTPUT_DIR/pentest.log"

# Logging function
log() {
    echo "[$(date +'%Y-%m-%d %H:%M:%S')] $*" | tee -a "$LOG_FILE"
}

# Start logging
log "=== Vexxy Pentest Sidecar Starting ==="
log "Target: $TARGET_HOST:$TARGET_PORT"
log "Max Runtime: ${MAX_RUNTIME}s"
log ""

# Wait for target to be ready
log "Waiting for target service to be ready..."
READY=false
for i in $(seq 1 30); do
    if nc -z -w 2 "$TARGET_HOST" "$TARGET_PORT" 2>/dev/null; then
        READY=true
        log "✓ Target is reachable at $TARGET_HOST:$TARGET_PORT"
        break
    fi
    log "  Attempt $i/30: Target not ready yet..."
    sleep 2
done

if [ "$READY" = false ]; then
    log "ERROR: Target service never became ready"
    echo '{"status": "error", "message": "Target not reachable"}' > "$SUMMARY_FILE"
    exit 1
fi

# Initialize results
FINDINGS=()
VULNERABILITIES_FOUND=0
SCAN_START=$(date +%s)

# Function to escape JSON string values
escape_json() {
    # Use jq to properly escape JSON strings
    echo -n "$1" | jq -R -s '.'
}

# Function to add finding
add_finding() {
    local severity="$1"
    local title="$2"
    local description="$3"
    local cve="${4:-}"

    # Properly escape all values for JSON
    local escaped_severity=$(escape_json "$severity")
    local escaped_title=$(escape_json "$title")
    local escaped_desc=$(escape_json "$description")
    local escaped_cve=$(escape_json "$cve")

    FINDINGS+=("{\"severity\": $escaped_severity, \"title\": $escaped_title, \"description\": $escaped_desc, \"cve\": $escaped_cve}")
    if [ "$severity" = "high" ] || [ "$severity" = "critical" ]; then
        VULNERABILITIES_FOUND=$((VULNERABILITIES_FOUND + 1))
    fi
    log "  [${severity^^}] $title"
}

###############################################################################
# Test 1: Port Scanning & Service Fingerprinting
###############################################################################
log ""
log "=== Test 1: Port Scanning ==="

# Full TCP scan on target port
log "Scanning port $TARGET_PORT..."
NMAP_OUTPUT=$(nmap -sV -p "$TARGET_PORT" --version-intensity 5 "$TARGET_HOST" -oX - 2>/dev/null || echo "<nmaprun/>")

# Parse service info
SERVICE_NAME=$(echo "$NMAP_OUTPUT" | xmlstarlet sel -t -v "//service/@name" 2>/dev/null || echo "unknown")
SERVICE_VERSION=$(echo "$NMAP_OUTPUT" | xmlstarlet sel -t -v "//service/@version" 2>/dev/null || echo "")
SERVICE_PRODUCT=$(echo "$NMAP_OUTPUT" | xmlstarlet sel -t -v "//service/@product" 2>/dev/null || echo "")

log "Service: $SERVICE_NAME $SERVICE_PRODUCT $SERVICE_VERSION"

# Check for known vulnerable versions (example patterns)
if [[ "$SERVICE_PRODUCT" =~ nginx ]] && [[ "$SERVICE_VERSION" =~ ^1\.1[0-4]\. ]]; then
    add_finding "high" "Outdated Nginx Version" "Running nginx $SERVICE_VERSION which may contain known vulnerabilities" ""
fi

###############################################################################
# Test 2: HTTP/HTTPS Testing (if web service)
###############################################################################
if [ "$SERVICE_NAME" = "http" ] || [ "$SERVICE_NAME" = "https" ] || [ "$TARGET_PORT" = "80" ] || [ "$TARGET_PORT" = "443" ] || [ "$TARGET_PORT" = "8080" ]; then
    log ""
    log "=== Test 2: HTTP Security Testing ==="

    PROTOCOL="http"
    if [ "$TARGET_PORT" = "443" ]; then
        PROTOCOL="https"
    fi

    URL="${PROTOCOL}://${TARGET_HOST}:${TARGET_PORT}"

    # Test 2.1: Check HTTP headers
    log "Checking HTTP security headers..."
    HEADERS=$(curl -s -I -m 5 "$URL" 2>/dev/null || echo "")

    if ! echo "$HEADERS" | grep -qi "X-Frame-Options"; then
        add_finding "medium" "Missing X-Frame-Options Header" "Server does not set X-Frame-Options, vulnerable to clickjacking" ""
    fi

    if ! echo "$HEADERS" | grep -qi "X-Content-Type-Options"; then
        add_finding "low" "Missing X-Content-Type-Options Header" "Server does not prevent MIME-type sniffing" ""
    fi

    if ! echo "$HEADERS" | grep -qi "Strict-Transport-Security" && [ "$PROTOCOL" = "https" ]; then
        add_finding "medium" "Missing HSTS Header" "HTTPS server does not enforce HTTP Strict Transport Security" ""
    fi

    # Test 2.2: Check for common paths
    log "Testing common paths..."

    COMMON_PATHS=(
        "/.git/config"
        "/.env"
        "/admin"
        "/api/debug"
        "/actuator"
        "/swagger-ui.html"
    )

    for path in "${COMMON_PATHS[@]}"; do
        STATUS=$(curl -s -o /dev/null -w "%{http_code}" -m 5 "${URL}${path}" 2>/dev/null || echo "000")
        if [ "$STATUS" = "200" ]; then
            add_finding "high" "Exposed Sensitive Path" "Path $path is publicly accessible (HTTP $STATUS)" ""
        fi
    done

    # Test 2.3: Check server version disclosure
    SERVER_HEADER=$(echo "$HEADERS" | grep -i "^Server:" | cut -d: -f2- | xargs || echo "")
    if [ -n "$SERVER_HEADER" ] && [[ "$SERVER_HEADER" =~ [0-9]+\.[0-9]+ ]]; then
        add_finding "info" "Server Version Disclosure" "Server header reveals version: $SERVER_HEADER" ""
    fi
fi

###############################################################################
# Test 3: Common Vulnerability Checks
###############################################################################
log ""
log "=== Test 3: Common Vulnerability Checks ==="

# Test for unencrypted protocols
if [ "$TARGET_PORT" = "21" ] || [ "$TARGET_PORT" = "23" ] || [ "$TARGET_PORT" = "8000" ]; then
    add_finding "medium" "Unencrypted Protocol" "Service uses unencrypted protocol on port $TARGET_PORT" ""
fi

# Test for default credentials (basic check)
if [ "$SERVICE_NAME" = "http" ] || [ "$SERVICE_NAME" = "https" ]; then
    PROTOCOL="http"
    [ "$TARGET_PORT" = "443" ] && PROTOCOL="https"

    # Try accessing with common default paths
    AUTH_TEST=$(curl -s -w "%{http_code}" -o /dev/null -m 5 "${PROTOCOL}://${TARGET_HOST}:${TARGET_PORT}/login" 2>/dev/null || echo "000")
    if [ "$AUTH_TEST" = "200" ]; then
        add_finding "info" "Authentication Endpoint Detected" "Login endpoint found at /login" ""
    fi
fi

###############################################################################
# Test 4: Network-Level Tests
###############################################################################
log ""
log "=== Test 4: Network Security ==="

# Check if service responds to external probes
log "Testing network exposure..."

# Simple connectivity test
if nc -z -w 2 "$TARGET_HOST" "$TARGET_PORT" 2>/dev/null; then
    log "✓ Service is network accessible"
else
    log "✗ Service is not responding"
    add_finding "info" "Service Unreachable" "Service did not respond to network probes" ""
fi

###############################################################################
# Generate Report
###############################################################################
SCAN_END=$(date +%s)
SCAN_DURATION=$((SCAN_END - SCAN_START))

log ""
log "=== Pentest Complete ==="
log "Duration: ${SCAN_DURATION}s"
log "Findings: ${#FINDINGS[@]}"
log "Vulnerabilities: $VULNERABILITIES_FOUND"

# Create JSON array of findings
FINDINGS_JSON="["
for i in "${!FINDINGS[@]}"; do
    FINDINGS_JSON+="${FINDINGS[$i]}"
    if [ $i -lt $((${#FINDINGS[@]} - 1)) ]; then
        FINDINGS_JSON+=","
    fi
done
FINDINGS_JSON+="]"

# Generate summary
cat > "$SUMMARY_FILE" <<EOF
{
  "status": "completed",
  "target": "$TARGET_HOST:$TARGET_PORT",
  "scan_duration_seconds": $SCAN_DURATION,
  "total_findings": ${#FINDINGS[@]},
  "vulnerabilities_found": $VULNERABILITIES_FOUND,
  "service_info": {
    "name": "$SERVICE_NAME",
    "product": "$SERVICE_PRODUCT",
    "version": "$SERVICE_VERSION"
  },
  "timestamp": "$(date -Iseconds)"
}
EOF

# Generate detailed report
cat > "$REPORT_FILE" <<EOF
{
  "pentest_report": {
    "metadata": {
      "target": "$TARGET_HOST:$TARGET_PORT",
      "scan_start": "$(date -d @$SCAN_START -Iseconds)",
      "scan_end": "$(date -d @$SCAN_END -Iseconds)",
      "duration_seconds": $SCAN_DURATION,
      "scanner": "vexxy-kali-pentester"
    },
    "service": {
      "name": "$SERVICE_NAME",
      "product": "$SERVICE_PRODUCT",
      "version": "$SERVICE_VERSION"
    },
    "findings": $FINDINGS_JSON,
    "summary": {
      "total_findings": ${#FINDINGS[@]},
      "vulnerabilities": $VULNERABILITIES_FOUND
    }
  }
}
EOF

log "Reports written to $OUTPUT_DIR"
log "Summary: $SUMMARY_FILE"
log "Detailed Report: $REPORT_FILE"

# Keep container alive for result extraction
log ""
log "Pentest complete. Container will remain running for result extraction."
log "Waiting for pod termination..."

# Sleep indefinitely (or until timeout)
sleep "$MAX_RUNTIME"
