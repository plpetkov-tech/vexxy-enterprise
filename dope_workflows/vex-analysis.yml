name: ðŸ” VEX Analysis

on:
  workflow_call:
    inputs:
      registry:
        required: true
        type: string
      image-name:
        required: true
        type: string
      image-digest:
        required: true
        type: string
      sbom-artifact:
        required: true
        type: string
      scan-artifact:
        required: true
        type: string
      vex-analysis-time:
        required: false
        type: string
        default: '15m'
      use-external-cluster:
        required: false
        type: boolean
        default: false
    outputs:
      build-vex-artifact:
        description: "Build-time VEX artifact ID"
        value: ${{ jobs.build-time-vex-analysis.outputs.build-vex-artifact }}
      runtime-vex-artifact:
        description: "Runtime VEX artifact ID"
        value: ${{ jobs.runtime-vex-generation.outputs.runtime-vex-artifact }}
      runtime-filtered-sbom-artifact:
        description: "Runtime filtered SBOM artifact ID"
        value: ${{ jobs.runtime-vex-generation.outputs.runtime-filtered-sbom-artifact }}

env:
  REGISTRY: ${{ inputs.registry }}
  IMAGE_NAME: ${{ inputs.image-name }}

jobs:
  # Build-time VEX generation (static analysis)
  build-time-vex-analysis:
    runs-on: ubuntu-latest
    outputs:
      build-vex-artifact: build-time-vex-${{ github.sha }}
    steps:
    - uses: actions/checkout@v4
    
    - name: ðŸ” Initialize Build-time VEX Analysis
      run: |
        echo "## ðŸ” Build-time VEX Analysis Phase" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "ðŸŽ¯ **Performing static vulnerability analysis and VEX generation**" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
    
    - name: Log in to Container Registry
      uses: docker/login-action@184bdaa0721073962dff0199f1fb9940f07167d1
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GHCR_PAT || secrets.GITHUB_TOKEN }}
    
    - name: Install vexctl
      uses: openvex/setup-vexctl@e85ca48f3c8a376289f6476129d59cda82147e71
      with:
        vexctl-release: '0.3.0'
    
    - name: Download SBOM
      uses: actions/download-artifact@634f93cb2916e3fdff6788551b99b062d0335ce0
      with:
        name: sbom-${{ github.sha }}
    
    - name: Download baseline scan
      uses: actions/download-artifact@634f93cb2916e3fdff6788551b99b062d0335ce0
      with:
        name: baseline-scan-${{ github.sha }}
    
    # Verify image accessibility before scanning
    - name: ðŸ” Verify image accessibility
      run: |
        IMAGE_REF="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ inputs.image-digest }}"
        echo "ðŸ” Verifying image accessibility: $IMAGE_REF"
        
        echo "### ðŸ” Image Verification" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # Try to inspect the image to ensure it's accessible
        if docker manifest inspect "$IMAGE_REF" > /dev/null 2>&1; then
          echo "âœ… **Image manifest accessible**" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ” **Image**: \`$IMAGE_REF\`" >> $GITHUB_STEP_SUMMARY
        elif docker pull "$IMAGE_REF" > /dev/null 2>&1; then
          echo "âœ… **Image successfully pulled**" >> $GITHUB_STEP_SUMMARY
        else
          echo "âŒ **Cannot access image - VEX attestation may fail**" >> $GITHUB_STEP_SUMMARY
          exit 1
        fi
        echo "" >> $GITHUB_STEP_SUMMARY
    
    # Scan the built container image
    - name: ðŸ›¡ï¸ Run Trivy vulnerability scanner on image
      uses: aquasecurity/trivy-action@dc5a429b52fcf669ce959baa2c2dd26090d2a6c4
      with:
        image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ inputs.image-digest }}
        format: 'json'
        output: 'container-scan.json'
    
    - name: ðŸ“‹ Run Trivy on SBOM
      uses: aquasecurity/trivy-action@dc5a429b52fcf669ce959baa2c2dd26090d2a6c4
      with:
        scan-type: 'sbom'
        scan-ref: 'sbom.json'
        format: 'sarif'
        output: 'trivy-sbom-results.sarif'

    - name: ðŸ“Š Process Container Scan Results
      uses: ./.github/actions/security-reporter
      with:
        phase: "container-scan"
        scan-file: "container-scan.json"
        title: "ðŸ›¡ï¸ Container Security Scan Results"

    # Collect existing VEX documents from .vex/production and other sources
    - name: ðŸ“„ Collect existing VEX documents
      run: |
        echo "ðŸ” Collecting existing VEX documents from repository..."
        mkdir -p vex-sources
        
        # ONLY collect from .vex/production (reliable runtime VEX)
        if [ -d ".vex/production" ]; then
          echo "ðŸŽ¯ Found .vex/production directory - collecting ONLY reliable production VEX documents..."
          find .vex/production -name "*.vex.json" -exec cp {} vex-sources/ \;
        fi
        
        # Skip all other sources - they are causing pollution
        echo "âš ï¸ Skipping .vex/consolidated and other sources to avoid placeholder pollution"
        
        echo "### ðŸ“„ Existing VEX Documents" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # List found VEX documents
        if [ -d "vex-sources" ] && [ "$(ls -A vex-sources 2>/dev/null)" ]; then
          VEX_COUNT=$(ls -1 vex-sources/*.vex.json 2>/dev/null | wc -l || echo "0")
          echo "âœ… **Found $VEX_COUNT existing VEX documents**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| File | Size | Source |" >> $GITHUB_STEP_SUMMARY
          echo "|------|------|--------|" >> $GITHUB_STEP_SUMMARY
          for vex_file in vex-sources/*.vex.json; do
            if [ -f "$vex_file" ]; then
              SIZE=$(stat -c%s "$vex_file" 2>/dev/null || echo "0")
              # Determine source based on filename patterns
              if [[ "$(basename $vex_file)" == *"runtime"* ]]; then
                SOURCE="ðŸš€ Runtime"
              elif [[ "$(basename $vex_file)" == *"final"* ]] || [[ "$(basename $vex_file)" == *"consolidated"* ]]; then
                SOURCE="ðŸ”„ Consolidated"
              elif [[ "$(basename $vex_file)" == *"production"* ]] || [[ "$(basename $vex_file)" == *"prod"* ]]; then
                SOURCE="ðŸ­ Production"
              elif [[ "$(basename $vex_file)" == *"build"* ]]; then
                SOURCE="ðŸ—ï¸ Build-time"
              else
                SOURCE="ðŸ“‹ Legacy"
              fi
              echo "| $(basename $vex_file) | ${SIZE} bytes | $SOURCE |" >> $GITHUB_STEP_SUMMARY
            fi
          done
        else
          echo "â„¹ï¸ **No existing VEX documents found**" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ“ **Checked locations**: .vex/production/, .vex/prod/, root directory" >> $GITHUB_STEP_SUMMARY
          touch vex-sources/.keep
        fi
        echo "" >> $GITHUB_STEP_SUMMARY

    # Generate build-time VEX from static scan results
    - name: ðŸ”§ Generate build-time VEX document
      run: |
        echo "ðŸ”§ Generating build-time VEX document..."
        IMAGE_REF="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ inputs.image-digest }}"
        
        # Get commit author for VEX document
        COMMIT_AUTHOR=$(git log -1 --pretty=format:'%an <%ae>')
        
        python scripts/generate_vex.py \
          --trivy-results container-scan.json \
          --sbom sbom.json \
          --image-ref "$IMAGE_REF" \
          --author "$COMMIT_AUTHOR" \
          --output build-time.vex.json
        
        echo "### ðŸ”§ Build-time VEX Generation" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        if [ -f "build-time.vex.json" ]; then
          STATEMENT_COUNT=$(jq '.statements | length' build-time.vex.json 2>/dev/null || echo "0")
          NOT_AFFECTED=$(jq '.statements | map(select(.status == "not_affected")) | length' build-time.vex.json 2>/dev/null || echo "0")
          AFFECTED=$(jq '.statements | map(select(.status == "affected")) | length' build-time.vex.json 2>/dev/null || echo "0")
          UNDER_INVESTIGATION=$(jq '.statements | map(select(.status == "under_investigation")) | length' build-time.vex.json 2>/dev/null || echo "0")
          
          echo "| ðŸ“Š VEX Statements | Count | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-------------------|-------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| âœ… Not Affected | $NOT_AFFECTED | Safe |" >> $GITHUB_STEP_SUMMARY
          echo "| âš ï¸ Affected | $AFFECTED | Requires Action |" >> $GITHUB_STEP_SUMMARY
          echo "| ðŸ” Under Investigation | $UNDER_INVESTIGATION | Pending |" >> $GITHUB_STEP_SUMMARY
          echo "| ðŸŽ¯ **Total Statements** | **$STATEMENT_COUNT** | |" >> $GITHUB_STEP_SUMMARY
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âœ… **Build-time VEX document generated successfully**" >> $GITHUB_STEP_SUMMARY
        else
          echo "âŒ **Failed to generate build-time VEX document**" >> $GITHUB_STEP_SUMMARY
        fi
        echo "" >> $GITHUB_STEP_SUMMARY

    # Create initial consolidated VEX (build-time + existing)
    - name: ðŸ”„ Create initial consolidated VEX
      uses: ./.github/actions/vex-processor
      with:
        action: "consolidate-build-vex"
        build-vex: "build-time.vex.json"
        existing-vex-dir: "vex-sources"
        image-ref: "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ inputs.image-digest }}"
        output: "initial-consolidated.vex.json"

    # Upload build-time VEX for runtime job
    - name: ðŸ“¤ Upload build-time VEX artifacts
      id: upload-build-vex
      uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02
      with:
        name: build-time-vex-${{ github.sha }}
        path: |
          build-time.vex.json
          initial-consolidated.vex.json
          container-scan.json
          trivy-sbom-results.sarif
        retention-days: 90

    - name: ðŸŽ¯ Complete Build-time VEX Phase
      run: |
        echo "---" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "## âœ… Build-time VEX Analysis Complete!" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "ðŸŽ‰ **Static vulnerability analysis and VEX generation finished**" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Next Phase**: ðŸš€ Runtime VEX Generation" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY

  # Runtime VEX generation with Kubescape
  runtime-vex-generation:
    needs: build-time-vex-analysis
    runs-on: ubuntu-latest
    outputs:
      runtime-vex-artifact: runtime-vex-${{ github.sha }}
      runtime-filtered-sbom-artifact: runtime-filtered-sbom-${{ github.sha }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8

      - name: ðŸš€ Initialize Runtime VEX Generation
        run: |
          echo "## ðŸš€ Runtime VEX Generation Phase" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "ðŸŽ¯ **Performing dynamic runtime security analysis with Kubescape**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

      - name: Install vexctl
        uses: openvex/setup-vexctl@e85ca48f3c8a376289f6476129d59cda82147e71
        with:
          vexctl-release: '0.3.0'

      - name: ðŸ”§ Setup KUBECONFIG if external cluster
        if: ${{ inputs.use-external-cluster }}
        run: |
          mkdir -p ~/.kube
          echo "${{ secrets.KUBECONFIG }}" | base64 -d > ~/.kube/config
          chmod 600 ~/.kube/config
          echo "âœ… KUBECONFIG configured for external cluster"

      # Set up runtime analysis environment
      - name: ðŸŽ² Setup Runtime Analysis Environment
        id: runtime-setup
        uses: ./.github/actions/runtime-analyzer
        with:
          action: "setup-cluster"
          cluster-name: "feelgood-cluster"
          vex-analysis-time: ${{ inputs.vex-analysis-time }}
          use-external-cluster: ${{ inputs.use-external-cluster }}

      - name: ðŸ›¡ï¸ Deploy and analyze application
        uses: ./.github/actions/runtime-analyzer
        with:
          action: "deploy-and-analyze"
          image-ref: "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ inputs.image-digest }}"
          app-name: "${{ github.event.repository.name }}"
          use-external-cluster: ${{ inputs.use-external-cluster }}

      - name: ðŸŽ­ Start background runtime testing
        run: |
          echo "ðŸŽ­ Starting continuous runtime testing during VEX analysis..."
          
          # Get node IP for testing
          NODE_IP=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="InternalIP")].address}')
          
          echo "### ðŸŽ­ Background Runtime Testing" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ”„ **Starting continuous testing to enhance VEX analysis**" >> $GITHUB_STEP_SUMMARY
          echo "ðŸŽ¯ **Target**: http://${NODE_IP}:30080" >> $GITHUB_STEP_SUMMARY
          echo "â±ï¸ **Duration**: Will run during VEX analysis period (${{ inputs.vex-analysis-time }})" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Convert analysis time to seconds for background testing
          ANALYSIS_TIME="${{ inputs.vex-analysis-time }}"
          if [[ "$ANALYSIS_TIME" =~ ^([0-9]+)m$ ]]; then
            BACKGROUND_DURATION=$((${BASH_REMATCH[1]} * 60))
          elif [[ "$ANALYSIS_TIME" =~ ^([0-9]+)s$ ]]; then
            BACKGROUND_DURATION=${BASH_REMATCH[1]}
          elif [[ "$ANALYSIS_TIME" =~ ^([0-9]+)h$ ]]; then
            BACKGROUND_DURATION=$((${BASH_REMATCH[1]} * 3600))
          else
            echo "âš ï¸ Invalid time format, defaulting to 120 seconds"
            BACKGROUND_DURATION=120
          fi
          
          echo "âš™ï¸ **Background test duration**: ${BACKGROUND_DURATION} seconds" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Start background testing script that will run for the entire VEX analysis period
          if [ -f "scripts/test-during-runtime.sh" ]; then
            echo "ðŸš€ Starting comprehensive background testing..."
            
            # Create a background testing script that repeats the test suite
            cat > background-runtime-test.sh << 'EOF'
          #!/bin/bash
          NODE_IP="$1"
          PORT="$2"
          DURATION="$3"
          
          echo "ðŸŽ­ Background runtime testing started at $(date)"
          echo "ðŸŽ¯ Target: http://${NODE_IP}:${PORT}"
          echo "â±ï¸ Duration: ${DURATION} seconds"
          
          START_TIME=$(date +%s)
          CYCLE=1
          TOTAL_REQUESTS=0
          TOTAL_SUCCESS=0
          
          while true; do
            CURRENT_TIME=$(date +%s)
            ELAPSED=$((CURRENT_TIME - START_TIME))
            
            if [ $ELAPSED -ge $DURATION ]; then
              echo "â° Background testing duration reached, stopping..."
              break
            fi
            
            echo "ðŸ”„ Test cycle $CYCLE (elapsed: ${ELAPSED}s/${DURATION}s)"
            
            # Run a smaller subset of tests for continuous testing
            bash scripts/test-during-runtime.sh "$NODE_IP" "$PORT" > "cycle-${CYCLE}-output.log" 2>&1 &
            TEST_PID=$!
            
            # Calculate dynamic timeout based on vex-analysis-time (max: analysis time, min: 60s)
            VEX_TIME_SECONDS=$(echo "${{ inputs.vex-analysis-time }}" | sed 's/m/*60/g; s/s//g; s/h/*3600/g' | bc -l 2>/dev/null | cut -d. -f1 || echo "120")
            TEST_TIMEOUT=$((VEX_TIME_SECONDS > 60 ? VEX_TIME_SECONDS : 60))
            
            # Wait for test to complete or timeout dynamically
            timeout $TEST_TIMEOUT wait $TEST_PID 2>/dev/null || {
              echo "âš ï¸ Test cycle $CYCLE timed out after ${TEST_TIMEOUT}s, killing..."
              kill $TEST_PID 2>/dev/null || true
            }
            
            # Extract stats if available
            if [ -f "cycle-${CYCLE}-output.log" ]; then
              CYCLE_REQUESTS=$(grep "Total Requests:" "cycle-${CYCLE}-output.log" | awk '{print $NF}' || echo "0")
              CYCLE_SUCCESS=$(grep "Successful:" "cycle-${CYCLE}-output.log" | awk '{print $NF}' || echo "0")
              TOTAL_REQUESTS=$((TOTAL_REQUESTS + CYCLE_REQUESTS))
              TOTAL_SUCCESS=$((TOTAL_SUCCESS + CYCLE_SUCCESS))
            fi
            
            CYCLE=$((CYCLE + 1))
            
            # Short pause between cycles
            sleep 10
          done
          
          echo "ðŸŽŠ Background testing completed!"
          echo "ðŸ“Š Total cycles: $((CYCLE - 1))"
          echo "ðŸ“Š Total requests: $TOTAL_REQUESTS"
          echo "ðŸ“Š Total successful: $TOTAL_SUCCESS"
          echo "ðŸ“Š Overall success rate: $((TOTAL_REQUESTS > 0 ? TOTAL_SUCCESS * 100 / TOTAL_REQUESTS : 0))%"
          
          # Save final stats
          cat > background-test-stats.json << STATS_EOF
          {
            "cycles": $((CYCLE - 1)),
            "total_requests": $TOTAL_REQUESTS,
            "total_success": $TOTAL_SUCCESS,
            "success_rate": $((TOTAL_REQUESTS > 0 ? TOTAL_SUCCESS * 100 / TOTAL_REQUESTS : 0)),
            "duration_seconds": $DURATION,
            "end_time": "$(date)"
          }
          STATS_EOF
          EOF
            
            chmod +x background-runtime-test.sh
            
            # Start background testing
            nohup bash background-runtime-test.sh "$NODE_IP" "30080" "$BACKGROUND_DURATION" > background-test.log 2>&1 &
            BACKGROUND_PID=$!
            
            echo "âœ… **Background testing started** (PID: $BACKGROUND_PID)" >> $GITHUB_STEP_SUMMARY
            echo "ðŸ”„ **Will run continuously during VEX analysis period**" >> $GITHUB_STEP_SUMMARY
            
            # Save PID for later cleanup
            echo "$BACKGROUND_PID" > background-test.pid
          else
            echo "âš ï¸ **Runtime test script not found, skipping background testing**" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY

      - name: ðŸ”§ Verify filtered SBOM configuration
        run: |
          echo "ðŸ”§ Verifying filtered SBOM configuration and triggering generation..."
          
          echo "### ðŸ”§ Filtered SBOM Configuration Check" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Check configuration via Helm values
          echo "ðŸ” Checking nodeAgent and kubevuln configuration..."
          if helm get values kubescape -n kubescape > helm-values.yaml 2>/dev/null; then
            echo "âœ… Retrieved Helm values"
            echo "ðŸ“‹ NodeAgent configuration:"
            grep -A 5 -B 2 "nodeAgent" helm-values.yaml || echo "No nodeAgent config found"
            echo "ðŸ“‹ Kubevuln configuration:"
            grep -A 5 -B 2 "kubevuln" helm-values.yaml || echo "No kubevuln config found"
          else
            echo "âš ï¸ Could not retrieve Helm values"
            # Fallback to checking pods and services
            echo "ðŸ“‹ Checking deployed resources instead..."
            kubectl get pods,svc,configmaps -n kubescape | head -10 || echo "Failed to get resources"
          fi
          
          # Check if relevant CRDs are installed
          echo "ðŸ” Checking required CRDs for filtered SBOM..."
          kubectl get crd | grep -E "(sbom|relevant)" || echo "Required CRDs not found"
          
          # Check nodeAgent pods specifically
          echo "ðŸ” Checking nodeAgent pod status..."
          kubectl get pods -n kubescape -l app.kubernetes.io/name=node-agent || echo "No nodeAgent pods found"
          
          # Try to get recent nodeAgent logs
          echo "ðŸ” Checking nodeAgent logs for SBOM activity..."
          kubectl logs -n kubescape -l app.kubernetes.io/name=node-agent --tail=20 | head -10 || echo "No nodeAgent logs available"
          
          # Force trigger SBOM generation by scaling nodeAgent if needed
          NODE_AGENT_PODS=$(kubectl get pods -n kubescape -l app.kubernetes.io/name=node-agent --no-headers | wc -l)
          if [ "$NODE_AGENT_PODS" -eq 0 ]; then
            echo "âš ï¸ No nodeAgent pods found, this may explain missing filtered SBOMs"
            echo "âš ï¸ **No nodeAgent pods found - filtered SBOM generation not available**" >> $GITHUB_STEP_SUMMARY
          else
            echo "âœ… Found $NODE_AGENT_PODS nodeAgent pod(s)"
            echo "âœ… **nodeAgent pods active: $NODE_AGENT_PODS**" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY

      - name: â³ Wait for runtime VEX generation
        run: |
          echo "â³ Waiting for Kubescape to generate runtime VEX documents..."
          echo "ðŸ• Start time: $(date)"
          echo "âš™ï¸ VEX analysis duration: ${{ inputs.vex-analysis-time }}"
          
          echo "### â³ Waiting for Runtime VEX Generation" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ” **Monitoring Kubescape for VEX document generation...**" >> $GITHUB_STEP_SUMMARY
          echo "âš™ï¸ **Configured analysis time: ${{ inputs.vex-analysis-time }}**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Convert analysis time to seconds for timeout calculation
          ANALYSIS_TIME="${{ inputs.vex-analysis-time }}"
          if [[ "$ANALYSIS_TIME" =~ ^([0-9]+)m$ ]]; then
            ANALYSIS_SECONDS=$((${BASH_REMATCH[1]} * 60))
          elif [[ "$ANALYSIS_TIME" =~ ^([0-9]+)s$ ]]; then
            ANALYSIS_SECONDS=${BASH_REMATCH[1]}
          elif [[ "$ANALYSIS_TIME" =~ ^([0-9]+)h$ ]]; then
            ANALYSIS_SECONDS=$((${BASH_REMATCH[1]} * 3600))
          else
            echo "âš ï¸ Invalid time format, defaulting to 120 seconds"
            ANALYSIS_SECONDS=120
          fi
          
          # Add buffer time (50% more than analysis time)
          WAIT_SECONDS=$((ANALYSIS_SECONDS + ANALYSIS_SECONDS / 2))
          WAIT_MINUTES=$((WAIT_SECONDS / 60))
          
          echo "ðŸ“Š **Wait strategy**: ${WAIT_MINUTES} minutes (analysis: ${ANALYSIS_SECONDS}s + buffer)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Wait for VEX documents with dynamic timeout
          for i in $(seq 1 $WAIT_MINUTES); do
            echo "â±ï¸  Minute $i/$WAIT_MINUTES - $(date)"
            
            # Try with full CRD name first, then fallback to short name
            VEX_COUNT=$(kubectl get openvulnerabilityexchangecontainers.spdx.softwarecomposition.kubescape.io -n kubescape 2>/dev/null | wc -l || echo "0")
            if [ "$VEX_COUNT" -eq 0 ]; then
              VEX_COUNT=$(kubectl get openvulnerabilityexchangecontainer -n kubescape 2>/dev/null | wc -l || echo "0")
            fi
            
            if [ "$VEX_COUNT" -gt 1 ]; then
              echo "ðŸ“„ Found $((VEX_COUNT-1)) runtime VEX document(s)"
              echo "âœ… **Runtime VEX documents generated in $i minutes**" >> $GITHUB_STEP_SUMMARY
              break
            else
              echo "ðŸ“„ No VEX documents generated yet..."
              echo "â±ï¸ **Minute $i/$WAIT_MINUTES**: No VEX documents yet..." >> $GITHUB_STEP_SUMMARY
            fi
            
            sleep 60
          done
          echo "" >> $GITHUB_STEP_SUMMARY

      - name: ðŸ“Š Collect background test results
        run: |
          echo "ðŸ“Š Collecting background runtime test results..."
          
          echo "### ðŸ“Š Background Testing Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Check if background testing completed and collect results
          if [ -f "background-test-stats.json" ]; then
            CYCLES=$(jq -r '.cycles // 0' background-test-stats.json)
            TOTAL_REQUESTS=$(jq -r '.total_requests // 0' background-test-stats.json)
            TOTAL_SUCCESS=$(jq -r '.total_success // 0' background-test-stats.json)
            SUCCESS_RATE=$(jq -r '.success_rate // 0' background-test-stats.json)
            
            echo "âœ… **Background testing completed successfully**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| ðŸŽ­ Background Test Results | Value |" >> $GITHUB_STEP_SUMMARY
            echo "|----------------------------|-------|" >> $GITHUB_STEP_SUMMARY
            echo "| ðŸ”„ Test Cycles | $CYCLES |" >> $GITHUB_STEP_SUMMARY
            echo "| ðŸ“Š Total Requests | $TOTAL_REQUESTS |" >> $GITHUB_STEP_SUMMARY
            echo "| âœ… Successful Requests | $TOTAL_SUCCESS |" >> $GITHUB_STEP_SUMMARY
            echo "| ðŸ“ˆ Success Rate | ${SUCCESS_RATE}% |" >> $GITHUB_STEP_SUMMARY
            echo "| ðŸŽ¯ Test Coverage | Health, API, Security, Fuzzing, Load, Edge Cases |" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
          elif [ -f "background-test.pid" ]; then
            BACKGROUND_PID=$(cat background-test.pid)
            if ps -p "$BACKGROUND_PID" > /dev/null 2>&1; then
              echo "ðŸ”„ **Background testing still running, stopping gracefully...**" >> $GITHUB_STEP_SUMMARY
              kill -TERM "$BACKGROUND_PID" 2>/dev/null || true
              sleep 5
              kill -KILL "$BACKGROUND_PID" 2>/dev/null || true
            fi
            
            # Try to get partial results
            if [ -f "background-test.log" ]; then
              PARTIAL_CYCLES=$(grep -c "Test cycle" background-test.log || echo "0")
              echo "âš ï¸ **Background testing stopped early**" >> $GITHUB_STEP_SUMMARY
              echo "ðŸ“Š **Partial results**: $PARTIAL_CYCLES test cycles completed" >> $GITHUB_STEP_SUMMARY
            else
              echo "âš ï¸ **Background testing did not complete**" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "â„¹ï¸ **No background testing was performed**" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "ðŸŽ¯ **Background testing enhanced runtime behavior analysis for VEX generation**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

      - name: ðŸ“Š Extract runtime VEX documents
        run: |
          echo "ðŸ“Š Extracting runtime VEX documents..."
          
          echo "### ðŸ“Š Runtime VEX Extraction" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Get all VEX resources with the full CRD name
          VEX_RESOURCES=$(kubectl get openvulnerabilityexchangecontainers.spdx.softwarecomposition.kubescape.io -n kubescape --no-headers 2>/dev/null || echo "")
          
          if [ -z "$VEX_RESOURCES" ]; then
            echo "âš ï¸ **No runtime VEX documents found from Kubescape**" >> $GITHUB_STEP_SUMMARY
            echo "ðŸ“‹ **Checking for alternative VEX resource names...**" >> $GITHUB_STEP_SUMMARY
            
            # Try shorter form as fallback
            VEX_RESOURCES=$(kubectl get openvulnerabilityexchangecontainer -n kubescape --no-headers 2>/dev/null || echo "")
            
            if [ -z "$VEX_RESOURCES" ]; then
              echo "ðŸ“‹ **No VEX documents found, creating placeholder**" >> $GITHUB_STEP_SUMMARY
              # Create empty placeholder to avoid workflow failures
              echo '{"@context": "https://openvex.dev/ns/v0.2.0", "statements": []}' > runtime.vex.json
              echo "ðŸ“„ **Created minimal placeholder for workflow continuity**" >> $GITHUB_STEP_SUMMARY
            else
              echo "âœ… **Found VEX documents using fallback resource name**" >> $GITHUB_STEP_SUMMARY
              VEX_COUNT=$(echo "$VEX_RESOURCES" | wc -l)
              echo "ðŸ“Š **Total VEX documents**: $VEX_COUNT" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              
              # List all found VEX documents for debugging
              echo "| ðŸ“‹ Found VEX Documents | Created At |" >> $GITHUB_STEP_SUMMARY
              echo "|------------------------|------------|" >> $GITHUB_STEP_SUMMARY
              echo "$VEX_RESOURCES" | while read -r line; do
                VEX_NAME=$(echo "$line" | awk '{print $1}')
                CREATED_AT=$(echo "$line" | awk '{print $2}')
                echo "| $VEX_NAME | $CREATED_AT |" >> $GITHUB_STEP_SUMMARY
              done
              echo "" >> $GITHUB_STEP_SUMMARY
              
              # Extract the first VEX document using fallback name
              FIRST_VEX=$(echo "$VEX_RESOURCES" | head -1 | awk '{print $1}')
              kubectl get openvulnerabilityexchangecontainer "$FIRST_VEX" -n kubescape -o jsonpath='{.spec}' > runtime.vex.json
              echo "ðŸ“„ **Runtime VEX extracted**: $FIRST_VEX" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "âœ… **Found runtime VEX documents**" >> $GITHUB_STEP_SUMMARY
            VEX_COUNT=$(echo "$VEX_RESOURCES" | wc -l)
            echo "ðŸ“Š **Total VEX documents**: $VEX_COUNT" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            # List all found VEX documents for debugging
            echo "| ðŸ“‹ Found VEX Documents | Created At |" >> $GITHUB_STEP_SUMMARY
            echo "|------------------------|------------|" >> $GITHUB_STEP_SUMMARY
            echo "$VEX_RESOURCES" | while read -r line; do
              VEX_NAME=$(echo "$line" | awk '{print $1}')
              CREATED_AT=$(echo "$line" | awk '{print $2}')
              echo "| $VEX_NAME | $CREATED_AT |" >> $GITHUB_STEP_SUMMARY
            done
            echo "" >> $GITHUB_STEP_SUMMARY
            
            # Look for our specific application image in the VEX documents
            APP_IMAGE_NAME="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}"
            # Convert image name to expected VEX resource naming pattern (replace special chars with -)
            VEX_PATTERN=$(echo "$APP_IMAGE_NAME" | sed 's|[/.:]|-|g' | tr '[:upper:]' '[:lower:]')
            
            echo "ðŸ” **Looking for VEX document matching our image pattern**: $VEX_PATTERN" >> $GITHUB_STEP_SUMMARY
            
            # Try to find a VEX document that matches our image
            MATCHING_VEX=$(echo "$VEX_RESOURCES" | grep -i "$VEX_PATTERN" | head -1 | awk '{print $1}' || echo "")
            
            if [ -n "$MATCHING_VEX" ]; then
              echo "ðŸŽ¯ **Found matching VEX document**: $MATCHING_VEX" >> $GITHUB_STEP_SUMMARY
              kubectl get openvulnerabilityexchangecontainers.spdx.softwarecomposition.kubescape.io "$MATCHING_VEX" -n kubescape -o jsonpath='{.spec}' > runtime.vex.json
              echo "ðŸ“„ **Extracted VEX for our application image**" >> $GITHUB_STEP_SUMMARY
            else
              echo "âš ï¸ **No VEX document found for our specific image, using first available**" >> $GITHUB_STEP_SUMMARY
              # Extract the first VEX document
              FIRST_VEX=$(echo "$VEX_RESOURCES" | head -1 | awk '{print $1}')
              kubectl get openvulnerabilityexchangecontainers.spdx.softwarecomposition.kubescape.io "$FIRST_VEX" -n kubescape -o jsonpath='{.spec}' > runtime.vex.json
              echo "ðŸ“„ **Extracted first available VEX**: $FIRST_VEX" >> $GITHUB_STEP_SUMMARY
            fi
          fi
          
          # Validate runtime VEX
          if jq empty runtime.vex.json 2>/dev/null; then
            STATEMENT_COUNT=$(jq '.statements | length' runtime.vex.json 2>/dev/null || echo "0")
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| ðŸ“‹ Runtime VEX Details | Value |" >> $GITHUB_STEP_SUMMARY
            echo "|-----------------------|-------|" >> $GITHUB_STEP_SUMMARY
            echo "| âœ… Valid JSON | Yes |" >> $GITHUB_STEP_SUMMARY
            echo "| ðŸ“Š Statements | $STATEMENT_COUNT |" >> $GITHUB_STEP_SUMMARY
            echo "| âš¡ Runtime Analysis | Complete |" >> $GITHUB_STEP_SUMMARY
          else
            echo "âŒ **Invalid runtime VEX JSON, creating placeholder**" >> $GITHUB_STEP_SUMMARY
            echo '{"@context": "https://openvex.dev/ns/v0.2.0", "statements": []}' > runtime.vex.json
          fi
          echo "" >> $GITHUB_STEP_SUMMARY

      - name: ðŸ“¦ Extract filtered SBOMs
        run: |
          echo "ðŸ“¦ Extracting filtered SBOM documents..."
          
          echo "### ðŸ“¦ Filtered SBOM Extraction" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Debug Kubescape configuration first
          echo "ðŸ” Checking Kubescape configuration for filtered SBOM storage..."
          kubectl get configmap -n kubescape kubescape-config -o yaml | grep -A 5 -B 5 "storeFilteredSbom" || echo "Config not found"
          
          # Check all available CRDs with more detail
          echo "ðŸ” Checking available Kubescape CRDs..."
          echo "ðŸ“‹ All CRDs:"
          kubectl get crd | grep kubescape || echo "No Kubescape CRDs found"
          echo "ðŸ“‹ SBOM-related CRDs:"
          kubectl get crd | grep sbom || echo "No SBOM CRDs found"
          
          # Try multiple potential CRD names
          echo "ðŸ” Attempting to find filtered SBOM resources..."
          FILTERED_SBOM_RESOURCES=""
          
          # List all potential CRD names
          POTENTIAL_CRDS=(
            "sbomsyftfiltereds.spdx.softwarecomposition.kubescape.io"
            "sbomsyftfiltered.spdx.softwarecomposition.kubescape.io" 
            "sbomsyftfiltereds"
            "sbomsyftfiltered"
            "filteredsboms.spdx.softwarecomposition.kubescape.io"
            "filteredsbom.spdx.softwarecomposition.kubescape.io"
          )
          
          for crd in "${POTENTIAL_CRDS[@]}"; do
            echo "ðŸ” Trying CRD: $crd"
            if kubectl get crd "$crd" >/dev/null 2>&1; then
              echo "âœ… Found CRD: $crd"
              FILTERED_SBOM_RESOURCES=$(kubectl get "$crd" -n kubescape --no-headers 2>/dev/null || echo "")
              if [ -n "$FILTERED_SBOM_RESOURCES" ]; then
                echo "âœ… Found filtered SBOM resources using: $crd"
                USED_CRD="$crd"
                break
              else
                echo "âš ï¸ CRD exists but no resources found: $crd"
              fi
            else
              echo "âŒ CRD not found: $crd"
            fi
          done
          
          # Debug: Show ALL custom resources in kubescape namespace
          echo "ðŸ” All custom resources in kubescape namespace:"
          kubectl api-resources --verbs=list --namespaced -o name | xargs -n 1 kubectl get --show-kind --ignore-not-found -n kubescape || echo "Failed to list resources"
          
          # Debug: Show specifically what SBOM-related resources exist
          echo "ðŸ” All SBOM-related custom resources:"
          kubectl api-resources | grep -i sbom || echo "No SBOM resources found"
          
          # Check if Kubescape is actually generating SBOMs
          echo "ðŸ” Checking for any SBOM generation activity..."
          kubectl logs -n kubescape -l app.kubernetes.io/name=kubevuln --tail=20 | grep -i sbom || echo "No SBOM logs found"
          
          if [ -z "$FILTERED_SBOM_RESOURCES" ]; then
            echo "âš ï¸ **No filtered SBOM documents found from Kubescape**" >> $GITHUB_STEP_SUMMARY
            echo "ðŸ“‹ **This may indicate that relevancy analysis is still processing**" >> $GITHUB_STEP_SUMMARY
            
            # Create empty placeholder to avoid workflow failures
            echo '{"bomFormat": "CycloneDX", "specVersion": "1.4", "components": []}' > runtime-filtered.sbom.json
            echo "ðŸ“„ **Created minimal placeholder for workflow continuity**" >> $GITHUB_STEP_SUMMARY
          else
            echo "âœ… **Found filtered SBOM documents**" >> $GITHUB_STEP_SUMMARY
            SBOM_COUNT=$(echo "$FILTERED_SBOM_RESOURCES" | wc -l)
            echo "ðŸ“Š **Total filtered SBOM documents**: $SBOM_COUNT" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            # List all found filtered SBOM documents for debugging
            echo "| ðŸ“‹ Found Filtered SBOMs | Created At |" >> $GITHUB_STEP_SUMMARY
            echo "|-------------------------|------------|" >> $GITHUB_STEP_SUMMARY
            echo "$FILTERED_SBOM_RESOURCES" | while read -r line; do
              SBOM_NAME=$(echo "$line" | awk '{print $1}')
              CREATED_AT=$(echo "$line" | awk '{print $2}')
              echo "| $SBOM_NAME | $CREATED_AT |" >> $GITHUB_STEP_SUMMARY
            done
            echo "" >> $GITHUB_STEP_SUMMARY
            
            # Look for our specific application image in the filtered SBOM documents
            APP_IMAGE_NAME="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}"
            # Convert image name to expected SBOM resource naming pattern (replace special chars with -)
            SBOM_PATTERN=$(echo "$APP_IMAGE_NAME" | sed 's|[/.:]|-|g' | tr '[:upper:]' '[:lower:]')
            
            echo "ðŸ” **Looking for filtered SBOM matching our image pattern**: $SBOM_PATTERN" >> $GITHUB_STEP_SUMMARY
            
            # Try to find a filtered SBOM document that matches our image
            MATCHING_SBOM=$(echo "$FILTERED_SBOM_RESOURCES" | grep -i "$SBOM_PATTERN" | head -1 | awk '{print $1}' || echo "")
            
            if [ -n "$MATCHING_SBOM" ]; then
              echo "ðŸŽ¯ **Found matching filtered SBOM**: $MATCHING_SBOM" >> $GITHUB_STEP_SUMMARY
              kubectl get "$USED_CRD" "$MATCHING_SBOM" -n kubescape -o jsonpath='{.spec}' > runtime-filtered.sbom.json
              echo "ðŸ“„ **Extracted filtered SBOM for our application image using CRD**: $USED_CRD" >> $GITHUB_STEP_SUMMARY
            else
              echo "âš ï¸ **No filtered SBOM found for our specific image, using first available**" >> $GITHUB_STEP_SUMMARY
              # Extract the first filtered SBOM document
              FIRST_SBOM=$(echo "$FILTERED_SBOM_RESOURCES" | head -1 | awk '{print $1}')
              kubectl get "$USED_CRD" "$FIRST_SBOM" -n kubescape -o jsonpath='{.spec}' > runtime-filtered.sbom.json
              echo "ðŸ“„ **Extracted first available filtered SBOM**: $FIRST_SBOM **using CRD**: $USED_CRD" >> $GITHUB_STEP_SUMMARY
            fi
          fi
          
          # Validate filtered SBOM
          if jq empty runtime-filtered.sbom.json 2>/dev/null; then
            COMPONENT_COUNT=$(jq '.components | length' runtime-filtered.sbom.json 2>/dev/null || echo "0")
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| ðŸ“‹ Filtered SBOM Details | Value |" >> $GITHUB_STEP_SUMMARY
            echo "|--------------------------|-------|" >> $GITHUB_STEP_SUMMARY
            echo "| âœ… Valid JSON | Yes |" >> $GITHUB_STEP_SUMMARY
            echo "| ðŸ“¦ Components | $COMPONENT_COUNT |" >> $GITHUB_STEP_SUMMARY
            echo "| ðŸŽ¯ Relevancy Analysis | Complete |" >> $GITHUB_STEP_SUMMARY
          else
            echo "âŒ **Invalid filtered SBOM JSON, creating placeholder**" >> $GITHUB_STEP_SUMMARY
            echo '{"bomFormat": "CycloneDX", "specVersion": "1.4", "components": []}' > runtime-filtered.sbom.json
          fi
          echo "" >> $GITHUB_STEP_SUMMARY

      - name: Upload runtime VEX
        id: upload-runtime-vex
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02
        with:
          name: runtime-vex-${{ github.sha }}
          path: runtime.vex.json
          retention-days: 30

      - name: Upload runtime filtered SBOM
        id: upload-runtime-filtered-sbom
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02
        with:
          name: runtime-filtered-sbom-${{ github.sha }}
          path: runtime-filtered.sbom.json
          retention-days: 30

      - name: ðŸ§¹ Cleanup Runtime Environment
        if: always()
        uses: ./.github/actions/runtime-analyzer
        with:
          action: "cleanup"
          cluster-name: "feelgood-cluster"
          use-external-cluster: ${{ inputs.use-external-cluster }}

      - name: ðŸŽ¯ Complete Runtime VEX Phase
        run: |
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## âœ… Runtime VEX Generation Complete!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "ðŸŽ‰ **Dynamic runtime security analysis finished**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Next Phase**: ðŸ”’ Final VEX Consolidation & Attestation" >> $GITHUB_STEP_SUMMARY
